(******************************************************************************
 * OC4.5
 * A pure OCaml implementation of C4.5 algorithm
 *
 * By Théophile Bastian <contact@tobast.fr>
 * and Noémie Fong (aka. Minithorynque), 2016.
 ******************************************************************************
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************)

(** This is the module's headcomment. And it's still a placeholder. What a
shame, it's clearly TODO. *)

(** {6 Data types } *)

exception InvalidArgument of string

(** A feature id. *)
type feature = int

(** A category (ie. classification) id. *)
type category = int

(** A value of a feature field. *)
type dataVal = int

(** A feature/data value association table. *)
type data = dataVal array

(** A value used to train the algorithm. *)
type trainVal = {
	data : data ;
	(** Associates each feature id to its value. If the feature is continuous,
	it may take any value; if the feature is discrete, it must be an integer in
	a range 0..N inclusive for a bound N inferred as the maximum of the given
	data. You can also set this bound manually with {!val:setFeatureMax}. *)

	category : category
	(** The category to which this data vector belongs. *)
}

(** Generated by {!val:emptyTrainSet}, represents a training set
for the algorithm. *)
type trainSet

(** Output of {!val:c45}. *)
type decisionTree

(** {6 Main functions} *)

(** Generates a decision tree from a training set.
@param trainSet The training set used, see {!val:emptyTrainSet}. *)
val c45 : trainSet -> decisionTree


(** {6 Training set manipulation} *)

(** [emptyTrainSet nbFeatures nbCategories featContinuity] creates an empty
train set with [nbFeatures] features and [nbCategories] categories. The array
[featContinuity] must have [nbFeatures] elements, with a [true] value if
the corresponding feature is continuous (that is, may take any value) or
[false] if the feature is discrete in a restrained set (eg., "Yes"/"No").

Raises {!exception:InvalidArgument} if [featContinuity] has not a length
of [nbFeatures]
*)
val emptyTrainSet : int -> int -> bool array -> trainSet

(** Adds the given value to the training set. *)
val addData : trainVal -> trainSet -> trainSet

(** [setFeatureMax feat maxVal trainSet] sets the maximum value the
{e discrete} feature [feat] may take. A discrete value is represented by
an integer between 0 and [maxVal] (inclusive).

In most cases, you won't have to call this function and the bound will be
automatically set to the maximum value you gave, but you can still set it in
case you need to have more values that are not represented.
*)
val setFeatureMax : int -> int -> trainSet -> unit

(** Returns the number of features. *)
val getNbFeatures : trainSet -> int

(** Returns the feature bound array, see {!val:setFeatureMax}. *)
val getFeatureMax : trainSet -> int array

(** Returns the feature continuity array, see {!val:emptyTrainSet}. *)
val getFeatContinuity : trainSet -> bool array

(** Returns the number of categories. *)
val getNbCategories : trainSet -> int

(** Returns the number of training cases in a given training set. *)
val getSetSize : trainSet -> int

(** {6 Pretty-printing} *)

(** Pretty-prints the given decision tree as a Dot file in the given
formatter. *)
val toDot : Format.formatter -> decisionTree -> unit

(** Same as {!val:toDot}, but prints directly to [stdout]. *)
val toDotStdout : decisionTree -> unit

